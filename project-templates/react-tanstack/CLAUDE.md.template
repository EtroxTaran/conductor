# Claude Code Context (Worker)

<!-- AUTO-GENERATED from project-templates/react-tanstack -->
<!-- Template: react-tanstack v1.0.0 -->
<!-- Project: {{PROJECT_NAME}} -->
<!-- Last synced: {{SYNC_DATE}} -->
<!-- DO NOT EDIT DIRECTLY - Changes will be overwritten on sync -->

You are implementing a React 19 + TanStack application.

## Your Role

You are the **Implementation Worker** - you write React application code following TDD practices. You have been spawned by the orchestrator to implement specific features.

## Primary Responsibilities

- Read the implementation plan from `.workflow/phases/planning/plan.json`
- Write failing tests FIRST (TDD with Vitest + Testing Library)
- Implement code to make tests pass
- Refactor while keeping tests green
- Report progress back to the orchestrator

## Technology Stack

| Technology | Purpose |
|------------|---------|
| React 19 | UI framework with new `use()` hook |
| TanStack Router | File-based routing |
| TanStack Query | Server state management |
| TanStack Form | Form state and validation |
| TanStack Table | Data tables |
| Shadcn/ui | Component library |
| Tailwind CSS | Styling |
| Vite | Build tooling |
| Vitest | Testing |

---

## React 19 Patterns

### The `use()` Hook
```tsx
// Read async data in components
function UserProfile({ userPromise }: { userPromise: Promise<User> }) {
  const user = use(userPromise);
  return <div>{user.name}</div>;
}

// Read context conditionally
function Component() {
  if (condition) {
    const theme = use(ThemeContext);
    return <div className={theme.class}>{theme.name}</div>;
  }
  return null;
}
```

### Server Components Awareness
- Mark client components with `'use client'` when needed
- Keep data fetching at route level when possible
- Use `startTransition` for non-urgent updates

---

## TanStack Router Patterns

### File-Based Routes
```
src/routes/
├── __root.tsx        # Root layout (wraps all routes)
├── index.tsx         # / route
├── about.tsx         # /about route
├── _authenticated/   # Layout group (no URL segment)
│   ├── route.tsx     # Auth guard layout
│   └── dashboard.tsx # /dashboard route
└── users/
    ├── index.tsx     # /users route
    └── $userId.tsx   # /users/:userId route
```

### Root Layout
```tsx
// src/routes/__root.tsx
import { createRootRouteWithContext, Outlet } from '@tanstack/react-router';
import { QueryClient } from '@tanstack/react-query';

interface RouterContext {
  queryClient: QueryClient;
}

export const Route = createRootRouteWithContext<RouterContext>()({
  component: RootLayout,
});

function RootLayout() {
  return (
    <>
      <header>...</header>
      <main>
        <Outlet />
      </main>
    </>
  );
}
```

### Route with Loader
```tsx
// src/routes/users/$userId.tsx
import { createFileRoute } from '@tanstack/react-router';
import { userQueryOptions } from '@/lib/api-client';

export const Route = createFileRoute('/users/$userId')({
  loader: ({ context: { queryClient }, params: { userId } }) =>
    queryClient.ensureQueryData(userQueryOptions(userId)),
  component: UserDetail,
});

function UserDetail() {
  const { userId } = Route.useParams();
  const user = Route.useLoaderData();
  return <div>{user.name}</div>;
}
```

---

## TanStack Query Patterns

### Query Options Factory
```tsx
// src/lib/api-client.ts
import { queryOptions } from '@tanstack/react-query';

export const userQueryOptions = (userId: string) =>
  queryOptions({
    queryKey: ['users', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

export const usersQueryOptions = () =>
  queryOptions({
    queryKey: ['users'],
    queryFn: fetchUsers,
  });
```

### Using Queries
```tsx
function UsersList() {
  const { data: users, isLoading } = useQuery(usersQueryOptions());

  if (isLoading) return <Skeleton />;
  return <ul>{users?.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

### Mutations
```tsx
function CreateUser() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });

  return <button onClick={() => mutation.mutate(data)}>Create</button>;
}
```

---

## TanStack Form Patterns

### Basic Form
```tsx
import { useForm } from '@tanstack/react-form';
import { zodValidator } from '@tanstack/zod-form-adapter';
import { z } from 'zod';

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

function LoginForm() {
  const form = useForm({
    defaultValues: { email: '', password: '' },
    validatorAdapter: zodValidator(),
    validators: { onChange: schema },
    onSubmit: async ({ value }) => {
      await login(value);
    },
  });

  return (
    <form onSubmit={(e) => { e.preventDefault(); form.handleSubmit(); }}>
      <form.Field
        name="email"
        children={(field) => (
          <Input
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
            error={field.state.meta.errors?.[0]}
          />
        )}
      />
      <Button type="submit" disabled={form.state.isSubmitting}>
        {form.state.isSubmitting ? 'Submitting...' : 'Submit'}
      </Button>
    </form>
  );
}
```

---

## Shadcn/ui Patterns

### Component Installation
```bash
# Install components via CLI (already configured)
pnpm dlx shadcn@latest add button card input
```

### Component Usage
```tsx
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';

function MyComponent() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Title</CardTitle>
      </CardHeader>
      <CardContent>
        <Input placeholder="Enter text..." />
        <Button variant="default">Submit</Button>
      </CardContent>
    </Card>
  );
}
```

### Customization
- Components are in `src/components/ui/`
- Modify directly for project-specific changes
- Use CSS variables in `globals.css` for theming

---

## Testing with Vitest

### Component Testing
```tsx
// tests/components/Button.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, vi } from 'vitest';
import { Button } from '@/components/ui/button';

describe('Button', () => {
  it('renders with text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();
  });

  it('calls onClick when clicked', async () => {
    const onClick = vi.fn();
    render(<Button onClick={onClick}>Click</Button>);

    await userEvent.click(screen.getByRole('button'));
    expect(onClick).toHaveBeenCalledOnce();
  });
});
```

### Testing with TanStack Query
```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });
}

function renderWithProviders(ui: React.ReactElement) {
  const queryClient = createTestQueryClient();
  return render(
    <QueryClientProvider client={queryClient}>
      {ui}
    </QueryClientProvider>
  );
}
```

### Run Tests
```bash
pnpm test           # Run tests in watch mode
pnpm test:coverage  # Run with coverage
```

---

## Project Structure

```
src/
├── components/
│   └── ui/              # Shadcn components
├── features/
│   └── {feature}/       # Feature modules
│       ├── components/
│       ├── hooks/
│       ├── services/
│       └── types.ts
├── hooks/               # Shared hooks
├── lib/
│   ├── api-client.ts    # API client + query options
│   └── utils.ts         # Utility functions (cn, etc.)
├── routes/              # TanStack Router file-based routes
│   ├── __root.tsx
│   ├── index.tsx
│   └── _authenticated/
├── App.tsx              # App entry with providers
└── main.tsx             # React entry point
```

---

## TDD Requirements

1. **Red**: Write a failing test that defines the expected behavior
2. **Green**: Write minimal code to make the test pass
3. **Refactor**: Clean up while keeping tests green

Never mark implementation complete with failing tests.

---

## Coding Standards

### Simplicity
- Prefer simple solutions over clever ones
- Don't over-engineer - solve the current problem
- Only add complexity when clearly necessary

### Consistency
- Follow existing patterns in the codebase
- Match the style of surrounding code
- Use consistent naming conventions

### TypeScript
- Use strict mode (`strict: true`)
- Prefer type inference where obvious
- Export types from feature modules

---

## MCP Server Integration

This project supports MCP servers for enhanced AI tooling.

### Available MCP Tools
- **Playwright**: Browser automation for E2E testing
- **Firecrawl**: Web scraping for documentation

### MCP-Friendly Patterns
- Clear file organization for easy navigation
- Consistent naming conventions
- Well-typed interfaces for tool discovery
- Explicit exports for code analysis

---

{{PROJECT_OVERRIDES}}
