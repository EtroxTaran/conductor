# Claude Code Context (Worker)

<!-- AUTO-GENERATED from project-templates/java-spring -->
<!-- Template: java-spring v1.0.0 -->
<!-- Project: {{PROJECT_NAME}} -->
<!-- Last synced: {{SYNC_DATE}} -->
<!-- DO NOT EDIT DIRECTLY - Changes will be overwritten on sync -->

You are implementing a Spring Boot 3 application with PostgreSQL.

## Your Role

You are the **Implementation Worker** - you write Java application code following TDD practices. You have been spawned by the orchestrator to implement specific features.

## Primary Responsibilities

- Read the implementation plan from `.workflow/phases/planning/plan.json`
- Write failing tests FIRST (TDD with JUnit 5)
- Implement code to make tests pass
- Refactor while keeping tests green
- Report progress back to the orchestrator

## Technology Stack

| Technology | Purpose |
|------------|---------|
| Spring Boot 3.2+ | Application framework |
| Gradle (Kotlin DSL) | Build tool |
| Spring Data JPA | Database access |
| PostgreSQL | Database |
| Spring Security | Authentication/Authorization |
| Lombok | Boilerplate reduction |
| MapStruct | DTO mapping |
| JUnit 5 + Mockito | Testing |

---

## Layered Architecture

```
{{PROJECT_NAME}}/
└── src/main/java/{{PACKAGE_PATH}}/
    ├── Application.java        # Entry point
    ├── config/                 # Configuration classes
    ├── controller/             # REST controllers
    ├── service/                # Business logic
    ├── repository/             # Data access
    ├── model/
    │   ├── entity/            # JPA entities
    │   └── dto/               # Data transfer objects
    └── exception/             # Custom exceptions
```

### Layer Responsibilities

| Layer | Responsibility |
|-------|----------------|
| Controller | HTTP handling, request validation, response formatting |
| Service | Business logic, transactions, orchestration |
| Repository | Data access, queries |
| Entity | Database mapping, JPA annotations |
| DTO | API request/response objects |

---

## Controller Patterns

### REST Controller
```java
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping
    public ResponseEntity<Page<UserDto>> findAll(Pageable pageable) {
        return ResponseEntity.ok(userService.findAll(pageable));
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDto> findById(@PathVariable Long id) {
        return ResponseEntity.ok(userService.findById(id));
    }

    @PostMapping
    public ResponseEntity<UserDto> create(@Valid @RequestBody CreateUserRequest request) {
        UserDto created = userService.create(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    @PutMapping("/{id}")
    public ResponseEntity<UserDto> update(
            @PathVariable Long id,
            @Valid @RequestBody UpdateUserRequest request) {
        return ResponseEntity.ok(userService.update(id, request));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        userService.delete(id);
        return ResponseEntity.noContent().build();
    }
}
```

### Request Validation
```java
public record CreateUserRequest(
    @NotBlank @Email String email,
    @NotBlank @Size(min = 1, max = 100) String name
) {}
```

---

## Service Patterns

### Service Class
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class UserService {

    private final UserRepository userRepository;
    private final UserMapper userMapper;

    public Page<UserDto> findAll(Pageable pageable) {
        return userRepository.findAll(pageable)
                .map(userMapper::toDto);
    }

    public UserDto findById(Long id) {
        return userRepository.findById(id)
                .map(userMapper::toDto)
                .orElseThrow(() -> new ResourceNotFoundException("User", id));
    }

    @Transactional
    public UserDto create(CreateUserRequest request) {
        if (userRepository.existsByEmail(request.email())) {
            throw new DuplicateResourceException("User with email already exists");
        }

        User user = userMapper.toEntity(request);
        User saved = userRepository.save(user);
        return userMapper.toDto(saved);
    }

    @Transactional
    public UserDto update(Long id, UpdateUserRequest request) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User", id));

        userMapper.updateEntity(user, request);
        User saved = userRepository.save(user);
        return userMapper.toDto(saved);
    }

    @Transactional
    public void delete(Long id) {
        if (!userRepository.existsById(id)) {
            throw new ResourceNotFoundException("User", id);
        }
        userRepository.deleteById(id);
    }
}
```

---

## Repository Patterns

### JPA Repository
```java
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User> findByEmail(String email);

    boolean existsByEmail(String email);

    @Query("SELECT u FROM User u WHERE u.name LIKE %:name%")
    Page<User> findByNameContaining(@Param("name") String name, Pageable pageable);
}
```

---

## Entity Patterns

### JPA Entity
```java
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String name;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
```

---

## DTO and Mapping

### DTO
```java
public record UserDto(
    Long id,
    String email,
    String name,
    LocalDateTime createdAt
) {}
```

### MapStruct Mapper
```java
@Mapper(componentModel = "spring")
public interface UserMapper {

    UserDto toDto(User user);

    User toEntity(CreateUserRequest request);

    void updateEntity(@MappingTarget User user, UpdateUserRequest request);
}
```

---

## Exception Handling

### Custom Exceptions
```java
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String resource, Object id) {
        super(String.format("%s not found with id: %s", resource, id));
    }
}

public class DuplicateResourceException extends RuntimeException {
    public DuplicateResourceException(String message) {
        super(message);
    }
}
```

### Global Exception Handler
```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {
        log.warn("Resource not found: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new ErrorResponse(ex.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidation(
            MethodArgumentNotValidException ex) {
        Map<String, String> errors = ex.getBindingResult().getFieldErrors().stream()
                .collect(Collectors.toMap(
                        FieldError::getField,
                        error -> error.getDefaultMessage() != null
                                ? error.getDefaultMessage()
                                : "Invalid value"
                ));
        return ResponseEntity.badRequest()
                .body(new ValidationErrorResponse("Validation failed", errors));
    }
}
```

---

## Testing

### Service Test
```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private UserMapper userMapper;

    @InjectMocks
    private UserService userService;

    @Test
    void findById_WhenExists_ReturnsUser() {
        // Arrange
        User user = User.builder().id(1L).email("test@example.com").build();
        UserDto dto = new UserDto(1L, "test@example.com", "Test", null);

        when(userRepository.findById(1L)).thenReturn(Optional.of(user));
        when(userMapper.toDto(user)).thenReturn(dto);

        // Act
        UserDto result = userService.findById(1L);

        // Assert
        assertThat(result.email()).isEqualTo("test@example.com");
        verify(userRepository).findById(1L);
    }

    @Test
    void findById_WhenNotExists_ThrowsException() {
        when(userRepository.findById(1L)).thenReturn(Optional.empty());

        assertThatThrownBy(() -> userService.findById(1L))
                .isInstanceOf(ResourceNotFoundException.class);
    }
}
```

### Integration Test
```java
@SpringBootTest
@AutoConfigureMockMvc
@Transactional
class UserControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void createUser_WithValidData_ReturnsCreated() throws Exception {
        CreateUserRequest request = new CreateUserRequest(
            "test@example.com",
            "Test User"
        );

        mockMvc.perform(post("/api/v1/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.email").value("test@example.com"));
    }
}
```

### Run Tests
```bash
./gradlew test           # Run all tests
./gradlew test --tests "*ServiceTest"  # Pattern matching
```

---

## TDD Requirements

1. **Red**: Write a failing test that defines the expected behavior
2. **Green**: Write minimal code to make the test pass
3. **Refactor**: Clean up while keeping tests green

Never mark implementation complete with failing tests.

---

## Coding Standards

### Java
- Use Java 21 features (records, pattern matching)
- Prefer immutability (records, final fields)
- Use constructor injection (via Lombok @RequiredArgsConstructor)
- Follow Spring naming conventions

### Database
- Use Flyway or Liquibase for migrations
- Index frequently queried columns
- Use proper relationships (OneToMany, ManyToOne)

---

## MCP Server Integration

This project supports MCP servers for enhanced AI tooling.

### Available MCP Tools
- **Database**: Direct database queries

### MCP-Friendly Patterns
- Clear package structure
- Consistent naming conventions
- Well-documented APIs

---

{{PROJECT_OVERRIDES}}
