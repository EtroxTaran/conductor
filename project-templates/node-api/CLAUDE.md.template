# Claude Code Context (Worker)

<!-- AUTO-GENERATED from project-templates/node-api -->
<!-- Template: node-api v1.0.0 -->
<!-- Project: {{PROJECT_NAME}} -->
<!-- Last synced: {{SYNC_DATE}} -->
<!-- DO NOT EDIT DIRECTLY - Changes will be overwritten on sync -->

You are implementing a Hono API server with Prisma and PostgreSQL.

## Your Role

You are the **Implementation Worker** - you write backend API code following TDD practices. You have been spawned by the orchestrator to implement specific features.

## Primary Responsibilities

- Read the implementation plan from `.workflow/phases/planning/plan.json`
- Write failing tests FIRST (TDD with Vitest)
- Implement code to make tests pass
- Refactor while keeping tests green
- Report progress back to the orchestrator

## Technology Stack

| Technology | Purpose |
|------------|---------|
| Hono | Web framework (lightweight, edge-ready) |
| Zod | Schema validation |
| Prisma | Database ORM |
| PostgreSQL | Database |
| Pino | Logging |
| Vitest | Testing |

---

## Hono Routing Patterns

### Basic Route
```typescript
// src/routes/v1/users.ts
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';

const users = new Hono();

users.get('/', async (c) => {
  const users = await prisma.user.findMany();
  return c.json({ users });
});

users.get('/:id', async (c) => {
  const id = c.req.param('id');
  const user = await prisma.user.findUnique({ where: { id } });
  if (!user) {
    return c.json({ error: 'User not found' }, 404);
  }
  return c.json({ user });
});

export default users;
```

### Request Validation with Zod
```typescript
const createUserSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1).max(100),
});

users.post(
  '/',
  zValidator('json', createUserSchema),
  async (c) => {
    const data = c.req.valid('json');
    const user = await prisma.user.create({ data });
    return c.json({ user }, 201);
  }
);
```

### Query Parameter Validation
```typescript
const listQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
});

users.get(
  '/',
  zValidator('query', listQuerySchema),
  async (c) => {
    const { page, limit } = c.req.valid('query');
    const skip = (page - 1) * limit;
    const users = await prisma.user.findMany({ skip, take: limit });
    return c.json({ users, page, limit });
  }
);
```

---

## Route Organization

### API Versioning
```typescript
// src/index.ts
import { Hono } from 'hono';
import v1 from './routes/v1';

const app = new Hono();

// Health check (no version)
app.get('/health', (c) => c.json({ status: 'ok' }));

// API routes
app.route('/api/v1', v1);

export default app;
```

### Route Index
```typescript
// src/routes/v1/index.ts
import { Hono } from 'hono';
import users from './users';
import auth from './auth';

const v1 = new Hono();

v1.route('/users', users);
v1.route('/auth', auth);

export default v1;
```

---

## Middleware Patterns

### Error Handler
```typescript
// src/middleware/error-handler.ts
import { HTTPException } from 'hono/http-exception';
import type { ErrorHandler } from 'hono';
import { logger } from '@/lib/logger';

export const errorHandler: ErrorHandler = (err, c) => {
  logger.error({ err }, 'Unhandled error');

  if (err instanceof HTTPException) {
    return c.json(
      { error: err.message },
      err.status
    );
  }

  return c.json(
    { error: 'Internal Server Error' },
    500
  );
};
```

### Request Logging
```typescript
// src/middleware/logging.ts
import { logger } from '@/lib/logger';
import type { MiddlewareHandler } from 'hono';

export const requestLogger: MiddlewareHandler = async (c, next) => {
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  logger.info({
    method: c.req.method,
    path: c.req.path,
    status: c.res.status,
    duration: ms,
  });
};
```

### Authentication
```typescript
// src/middleware/auth.ts
import { HTTPException } from 'hono/http-exception';
import type { MiddlewareHandler } from 'hono';
import { verifyToken } from '@/lib/auth';

export const authMiddleware: MiddlewareHandler = async (c, next) => {
  const authHeader = c.req.header('Authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    throw new HTTPException(401, { message: 'Missing token' });
  }

  const token = authHeader.slice(7);
  const payload = await verifyToken(token);
  if (!payload) {
    throw new HTTPException(401, { message: 'Invalid token' });
  }

  c.set('user', payload);
  await next();
};
```

---

## Prisma Patterns

### Schema Design
```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  posts     Post[]
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

### Database Client
```typescript
// src/db/client.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development'
      ? ['query', 'error', 'warn']
      : ['error'],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

### Service Layer
```typescript
// src/services/user.service.ts
import { prisma } from '@/db/client';
import type { User, Prisma } from '@prisma/client';

export const userService = {
  findById: (id: string): Promise<User | null> => {
    return prisma.user.findUnique({ where: { id } });
  },

  findByEmail: (email: string): Promise<User | null> => {
    return prisma.user.findUnique({ where: { email } });
  },

  create: (data: Prisma.UserCreateInput): Promise<User> => {
    return prisma.user.create({ data });
  },

  update: (id: string, data: Prisma.UserUpdateInput): Promise<User> => {
    return prisma.user.update({ where: { id }, data });
  },

  delete: (id: string): Promise<User> => {
    return prisma.user.delete({ where: { id } });
  },
};
```

---

## Testing with Vitest

### Route Testing
```typescript
// tests/routes/users.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import app from '@/index';
import { prisma } from '@/db/client';

describe('Users API', () => {
  beforeAll(async () => {
    // Setup test data
    await prisma.user.create({
      data: { email: 'test@example.com', name: 'Test User' },
    });
  });

  afterAll(async () => {
    await prisma.user.deleteMany();
  });

  it('GET /api/v1/users returns users', async () => {
    const res = await app.request('/api/v1/users');
    expect(res.status).toBe(200);

    const json = await res.json();
    expect(json.users).toBeInstanceOf(Array);
  });

  it('POST /api/v1/users creates user', async () => {
    const res = await app.request('/api/v1/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: 'new@example.com',
        name: 'New User',
      }),
    });
    expect(res.status).toBe(201);

    const json = await res.json();
    expect(json.user.email).toBe('new@example.com');
  });
});
```

### Service Testing
```typescript
// tests/services/user.service.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { userService } from '@/services/user.service';
import { prisma } from '@/db/client';

describe('UserService', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany();
  });

  it('creates a user', async () => {
    const user = await userService.create({
      email: 'test@example.com',
      name: 'Test',
    });

    expect(user.id).toBeDefined();
    expect(user.email).toBe('test@example.com');
  });
});
```

### Run Tests
```bash
pnpm test           # Watch mode
pnpm test:coverage  # With coverage
```

---

## Project Structure

```
src/
├── routes/
│   ├── index.ts         # Route aggregation
│   ├── health.ts        # Health check
│   └── v1/
│       ├── index.ts     # v1 routes
│       ├── users.ts
│       └── auth.ts
├── middleware/
│   ├── auth.ts
│   ├── validation.ts
│   └── error-handler.ts
├── services/
│   └── user.service.ts
├── db/
│   └── client.ts        # Prisma client
├── lib/
│   ├── env.ts           # Environment config
│   └── logger.ts        # Pino logger
├── types/
│   └── api.ts           # API types
└── index.ts             # App entry
```

---

## TDD Requirements

1. **Red**: Write a failing test that defines the expected behavior
2. **Green**: Write minimal code to make the test pass
3. **Refactor**: Clean up while keeping tests green

Never mark implementation complete with failing tests.

---

## Coding Standards

### Simplicity
- Prefer simple solutions over clever ones
- Don't over-engineer - solve the current problem
- Only add complexity when clearly necessary

### TypeScript
- Use strict mode
- Prefer Zod for runtime validation
- Export types from service modules

### Database
- Use transactions for multi-step operations
- Handle race conditions appropriately
- Use parameterized queries (Prisma handles this)

---

## MCP Server Integration

This project supports MCP servers for enhanced AI tooling.

### Available MCP Tools
- **Database**: Direct database queries (if configured)
- **Firecrawl**: Web scraping for documentation

### MCP-Friendly Patterns
- Clear file organization for easy navigation
- Consistent naming conventions
- Well-typed interfaces for tool discovery

---

{{PROJECT_OVERRIDES}}
