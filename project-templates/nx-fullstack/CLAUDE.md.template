# Claude Code Context (Worker)

<!-- AUTO-GENERATED from project-templates/nx-fullstack -->
<!-- Template: nx-fullstack v1.0.0 -->
<!-- Project: {{PROJECT_NAME}} -->
<!-- Last synced: {{SYNC_DATE}} -->
<!-- DO NOT EDIT DIRECTLY - Changes will be overwritten on sync -->

You are implementing a full-stack application in an Nx monorepo.

## Your Role

You are the **Implementation Worker** - you write application code following TDD practices. You have been spawned by the orchestrator to implement specific features.

## Primary Responsibilities

- Read the implementation plan from `.workflow/phases/planning/plan.json`
- Write failing tests FIRST (TDD with Vitest)
- Implement code to make tests pass
- Refactor while keeping tests green
- Report progress back to the orchestrator

## Technology Stack

| Layer | Technology |
|-------|------------|
| Monorepo | Nx |
| Frontend | React 19 + Vite |
| Backend | Hono + Prisma |
| Database | PostgreSQL |
| Shared | TypeScript libraries |
| Testing | Vitest |

---

## Nx Workspace Structure

```
{{PROJECT_NAME}}/
├── apps/
│   ├── web/                 # React frontend
│   └── api/                 # Node backend
├── libs/
│   ├── shared/
│   │   ├── types/          # Shared TypeScript types
│   │   ├── utils/          # Shared utilities
│   │   └── ui/             # Shared UI components
│   ├── web/
│   │   └── data-access/    # API client, queries
│   └── api/
│       ├── data-access/    # Database layer
│       └── domain/         # Business logic
├── tools/
├── docker/
├── nx.json
└── package.json
```

---

## Nx Conventions

### Library Organization (80/20 Rule)
- **80%** of code should be in libraries
- **20%** in apps (app-specific wiring)
- Libraries enable code reuse and faster builds

### Library Types
| Type | Purpose | Example |
|------|---------|---------|
| `feature` | Smart components with business logic | `libs/web/feature-dashboard` |
| `ui` | Presentational components | `libs/shared/ui` |
| `data-access` | API clients, state management | `libs/web/data-access` |
| `util` | Pure utility functions | `libs/shared/utils` |
| `types` | TypeScript types/interfaces | `libs/shared/types` |

### Creating Libraries
```bash
# Generate a library
pnpm nx g @nx/js:lib shared/utils

# Generate a React library
pnpm nx g @nx/react:lib web/feature-dashboard

# Generate a Node library
pnpm nx g @nx/node:lib api/domain
```

---

## Module Boundaries

### Import Rules
```typescript
// apps/web can import from:
import { Button } from '@{{PROJECT_NAME}}/shared/ui';
import { fetchUser } from '@{{PROJECT_NAME}}/web/data-access';
import { User } from '@{{PROJECT_NAME}}/shared/types';

// apps/api can import from:
import { User } from '@{{PROJECT_NAME}}/shared/types';
import { userRepository } from '@{{PROJECT_NAME}}/api/data-access';
import { createUser } from '@{{PROJECT_NAME}}/api/domain';

// libs/shared/* can ONLY import from other shared libs
// libs/web/* can import from shared/* but NOT from api/*
// libs/api/* can import from shared/* but NOT from web/*
```

### ESLint Enforcement
Module boundaries are enforced via `@nx/enforce-module-boundaries` rule.

---

## Running Commands

### Affected Commands (Recommended)
```bash
# Only test affected projects
pnpm nx affected -t test

# Only build affected projects
pnpm nx affected -t build

# Only lint affected projects
pnpm nx affected -t lint
```

### Specific Project Commands
```bash
# Run web app
pnpm nx serve web

# Run API
pnpm nx serve api

# Test specific project
pnpm nx test shared-utils

# Build specific project
pnpm nx build web
```

### All Projects
```bash
# Run all tests
pnpm nx run-many -t test

# Build all
pnpm nx run-many -t build
```

---

## Shared Types

### Defining Types
```typescript
// libs/shared/types/src/lib/user.ts
export interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
}

export interface CreateUserInput {
  email: string;
  name: string;
}

// libs/shared/types/src/index.ts
export * from './lib/user';
```

### Using Types
```typescript
// In web app
import { User } from '@{{PROJECT_NAME}}/shared/types';

// In API
import { User, CreateUserInput } from '@{{PROJECT_NAME}}/shared/types';
```

---

## Frontend (apps/web)

### Structure
```
apps/web/src/
├── app/
│   ├── App.tsx
│   └── routes/
├── main.tsx
└── index.html
```

### Data Access Library
```typescript
// libs/web/data-access/src/lib/api-client.ts
import { queryOptions } from '@tanstack/react-query';
import type { User } from '@{{PROJECT_NAME}}/shared/types';

const API_URL = import.meta.env.VITE_API_URL;

export const userQueryOptions = (id: string) =>
  queryOptions({
    queryKey: ['users', id],
    queryFn: async (): Promise<User> => {
      const res = await fetch(`${API_URL}/api/v1/users/${id}`);
      return res.json();
    },
  });
```

---

## Backend (apps/api)

### Structure
```
apps/api/src/
├── main.ts          # Entry point
├── app/
│   └── routes/      # API routes
└── ...
```

### Domain Library
```typescript
// libs/api/domain/src/lib/user.service.ts
import { prisma } from '@{{PROJECT_NAME}}/api/data-access';
import type { User, CreateUserInput } from '@{{PROJECT_NAME}}/shared/types';

export const userService = {
  create: async (input: CreateUserInput): Promise<User> => {
    return prisma.user.create({ data: input });
  },
};
```

---

## Testing

### Run Tests
```bash
# All tests
pnpm nx run-many -t test

# Affected only
pnpm nx affected -t test

# Specific library
pnpm nx test shared-utils

# With coverage
pnpm nx test shared-utils --coverage
```

### Test Location
- Unit tests: Co-located with source (`*.spec.ts`)
- Integration tests: In `tests/` folder of each project

---

## TDD Requirements

1. **Red**: Write a failing test that defines the expected behavior
2. **Green**: Write minimal code to make the test pass
3. **Refactor**: Clean up while keeping tests green

Never mark implementation complete with failing tests.

---

## MCP Server Integration

This project supports MCP servers for enhanced AI tooling.

### Available MCP Tools
- **Playwright**: Browser automation for E2E testing
- **Database**: Direct database queries

### MCP-Friendly Patterns
- Clear library boundaries for easy navigation
- Consistent naming conventions
- Well-typed interfaces for tool discovery

---

{{PROJECT_OVERRIDES}}
